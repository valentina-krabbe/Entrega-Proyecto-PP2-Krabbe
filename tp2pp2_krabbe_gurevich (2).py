# -*- coding: utf-8 -*-
"""TP2PP2_Krabbe_Gurevich.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gDeBjqu6Giyb9zhWCeQpsAwMTmJWYois
"""

# @title
!pip install plotly

# @title
from IPython.display import HTML

HTML('''
<style>
body {
  background: radial-gradient(circle at bottom, #060606 0%, #000000 80%);
  color: #f5f5f5;
  font-family: 'Poppins', sans-serif;
  letter-spacing: 0.3px;
  overflow-x: hidden;
}

.container {
  max-width: 1000px;
  margin: 50px auto;
  background: linear-gradient(145deg, rgba(20,20,20,0.95), rgba(30,0,30,0.9));
  border-radius: 25px;
  padding: 40px;
  box-shadow: 0 0 30px #00ff9975, 0 0 60px #ff00aa55;
  border: 1px solid rgba(255,255,255,0.1);
  backdrop-filter: blur(8px);
}

h1, h2, h3 {
  text-align: center;
  text-transform: uppercase;
}

h1 {
  font-size: 2.5em;
  background: linear-gradient(90deg, #00ff99, #ff00aa);
  -webkit-background-clip: text;
  color: transparent;
  text-shadow: 0 0 20px #00ff9975, 0 0 40px #ff00aa55;
}

h2 {
  font-size: 1.6em;
  color: #ffb3e6;
  margin-top: -5px;
  text-shadow: 0 0 15px #ff00aa;
}

h3 {
  color: #00ff99;
  margin-top: 25px;
  text-shadow: 0 0 10px #00ff99;
}

.card {
  background: rgba(0,0,0,0.6);
  border: 1px solid #00ff9966;
  border-radius: 20px;
  padding: 25px;
  margin: 25px 0;
  box-shadow: 0 0 25px #00ff9944, 0 0 35px #ff00aa33 inset;
  transition: all 0.3s;
}

.card:hover {
  transform: scale(1.02);
  box-shadow: 0 0 30px #ff00aa55, 0 0 45px #00ff9966 inset;
}

pre {
  background: rgba(10,10,10,0.85);
  color: #00ffcc;
  border-left: 4px solid #ff00aa;
  padding: 10px 15px;
  border-radius: 10px;
  overflow-x: auto;
}

footer {
  text-align: center;
  color: #888;
  margin-top: 40px;
  font-size: 0.9em;
}
</style>
''')

# @title
from IPython.display import HTML

HTML('''
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;500&display=swap');

body {
  background: radial-gradient(circle at top left, #020202 0%, #080014 40%, #000000 100%);
  color: #f5f5f5;
  font-family: 'Poppins', sans-serif;
  letter-spacing: 0.4px;
  overflow-x: hidden;
}

/* contenedor principal */
.container {
  max-width: 950px;
  margin: 70px auto;
  background: linear-gradient(145deg, rgba(10,10,10,0.95), rgba(25,0,25,0.9));
  border-radius: 30px;
  padding: 50px;
  box-shadow: 0 0 30px #00ff9980, 0 0 60px #ff00aa80;
  border: 1px solid rgba(255,255,255,0.15);
  backdrop-filter: blur(8px);
  animation: pulse 5s infinite alternate; /* Mantenido aqu√≠ */
}

/* T√≠tulos con ne√≥n */
h1 {
  text-align: center;
  font-size: 2.8em;
  background: linear-gradient(90deg, #00ff99, #ff00aa);
  -webkit-background-clip: text;
  color: transparent;
  text-shadow: 0 0 20px #00ff99aa, 0 0 40px #ff00aaaa;
  font-family: 'Orbitron', sans-serif;
}

h2 {
  text-align: center;
  font-size: 1.6em;
  color: #ffb3e6;
  text-shadow: 0 0 10px #ff00aa;
  margin-top: -10px;
}

.card {
  background: rgba(0,0,0,0.6);
  border: 1px solid #00ff9970;
  border-radius: 20px;
  padding: 25px;
  margin: 30px auto;
  box-shadow: 0 0 25px #00ff9960 inset, 0 0 30px #ff00aa40;
  transition: 0.3s;
  text-align: center;
}

.card:hover {
  transform: scale(1.02);
  box-shadow: 0 0 40px #ff00aa80, 0 0 50px #00ff9980 inset;
}

/* texto */
p, b {
  font-size: 1.05em;
}

.highlight {
  color: #00ffcc;
  text-shadow: 0 0 10px #00ffcc;
}

.name1 {
  color: #00ff99;
  text-shadow: 0 0 10px #00ff99;
}

.name2 {
  color: #ff00aa;
  text-shadow: 0 0 10px #ff00aa;
}

/* p√°rrafo de descripci√≥n */
.description {
  margin-top: 40px;
  padding: 0 20px;
  text-align: justify;
  line-height: 1.6;
  border-left: 5px solid #00ff99;
  background: rgba(0,0,0,0.4);
  padding: 20px;
  border-radius: 10px;
}
.description b {
  color: #00ffcc;
  text-shadow: none;
}


/* animaci√≥n fondo pulsante */
@keyframes pulse {
  0% { box-shadow: 0 0 20px #00ff9966, 0 0 30px #ff00aa66; }
  50% { box-shadow: 0 0 40px #00ff99aa, 0 0 70px #ff00aaaa; }
  100% { box-shadow: 0 0 20px #00ff9966, 0 0 30px #ff00aa66; }
}
</style>

<div class="container">
  <h1>Primer Parcial de PP2 üë©‚Äçüíªüìä</h1>
  <h2>¬øQu√© variables impactan en la p√©rdida de talento en las organizaciones? ü§î</h2>

  <div class="card">
    <p><b class="highlight">Integrantes:</b></p>
    <p>üíö <b class="name1">Valentina Krabbe</b> ‚Äî DNI 45207992</p>
    <p>üíñ <b class="name2">Melisa Gurevich</b> ‚Äî DNI 35365884</p>
  </div>

  <p class="description">
    En este proyecto analizaremos un dataset elaborado por un analista de Recursos Humanos, el cual recopila informaci√≥n de empleados actuales y antiguos (<b>35 variables en total</b>). El objetivo es identificar y comprender los factores que influyen en la rotaci√≥n y abandono de personal dentro de la empresa.
  </p>
</div>
''')

"""### Importaci√≥n de librerias y herramientas"""

!pip install imbalanced-learn

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import StackingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import precision_recall_curve, roc_auc_score, accuracy_score, classification_report, roc_curve
import seaborn as sn
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE               #El algoritmo de sobremuestreo
from imblearn.pipeline import Pipeline as ImbPipeline  #Permite usar SMOTE dentro del Pipeline
from sklearn.preprocessing import FunctionTransformer  #Para Naive Bayes
from sklearn.model_selection import GridSearchCV, StratifiedKFold
from sklearn.metrics import classification_report
from IPython.display import display, HTML

"""### Importamos el dataset alojado en GitHub"""

url="https://raw.githubusercontent.com/valentina-krabbe/Practicamos-Profesionales-2/refs/heads/main/empleadosRRHH.csv"

df=pd.read_csv(url)

print(df.head())

"""- Se compone de 35 variables relacionadas con empleados, como edad, viajes, departamento, satisfacci√≥n y a√±os en la empresa.

- Vemos un ejemplo de las primeras filas para conocer su estructura.

- Presencia de muchas variables distintas para analizar la rotaci√≥n.

###Cambiamos en la columna "Rotacion" las variables Yes y No por 1 y 0
"""

df["Attrition"] = df["Attrition"].replace({"Yes": 1, "No": 0}).astype(int)

"""### Modificamos los nombres de las columnas"""

# Diccionario: columna_original : "nuevo_nombre"
nuevos_nombres = {
    "Age": "Edad",
    "Attrition": "Rotacion",
    "BusinessTravel": "Viajes_Negocios",
    "DailyRate": "Salario_Diario",
    "Department": "Departamento",
    "DistanceFromHome": "Distancia_Hogar",
    "Education": "Nivel_Educativo",
    "EducationField": "Area_Educacion",
    "EmployeeCount": "Conteo_Empleados",
    "EmployeeNumber": "Numero_Empleado",
    "EnvironmentSatisfaction": "Satisfaccion_Entorno",
    "Gender": "Genero",
    "HourlyRate": "Salario_Hora",
    "JobInvolvement": "Compromiso_Trabajo",
    "JobLevel": "Nivel_Puesto",
    "JobRole": "Rol_Laboral",
    "JobSatisfaction": "Satisfaccion_Trabajo",
    "MaritalStatus": "Estado_Civil",
    "MonthlyIncome": "Ingreso_Mensual",
    "MonthlyRate": "Salario_Mensual",
    "NumCompaniesWorked": "Empresas_Trabajadas",
    "Over18": "Mayor_18",
    "OverTime": "Horas_Extra",
    "PercentSalaryHike": "Aumento_Salarial_Porc",
    "PerformanceRating": "Calificacion_Desempeno",
    "RelationshipSatisfaction": "Satisfaccion_Relaciones",
    "StandardHours": "Horas_Estandar",
    "StockOptionLevel": "Nivel_Acciones",
    "TotalWorkingYears": "Anios_Experiencia_Total",
    "TrainingTimesLastYear": "Capacitaciones_Ultimo_Anio",
    "WorkLifeBalance": "Balance_Vida_Trabajo",
    "YearsAtCompany": "Anios_Empresa",
    "YearsInCurrentRole": "Anios_Puesto_Actual",
    "YearsSinceLastPromotion": "Anios_Desde_Promocion",
    "YearsWithCurrManager": "Anios_Con_Jefe"
}

df=df.rename(columns=nuevos_nombres)

print(df.head())

"""- Primero convertimos la variable Rotaci√≥n de texto (‚ÄòYes‚Äô/‚ÄòNo‚Äô) a valores num√©ricos 1 y 0, para que el modelo pueda trabajar con ella.

- Despu√©s renombramos las columnas con nombres m√°s claros en espa√±ol, como Edad, Ingreso Mensual, Satisfacci√≥n en el Trabajo, etc.

- Esto facilita la interpretaci√≥n de los resultados y que los gr√°ficos sean m√°s entendibles.

- Con el dataset limpio y en espa√±ol, ya podemos empezar a analizar las variables y entrenar nuestro modelo.

## Procesamiento y Exploraci√≥n de datos

Verificaci√≥n de nulos
"""

df.info()

"""Visualizamos las estadisticas principales"""

df.describe()

print(df.groupby('Rotacion').size())

# @title
import plotly.express as px

# Obtener el conteo de valores √∫nicos en la columna 'comprar'
conteo_comprar = df['Rotacion'].value_counts()

# Crear un DataFrame con el conteo
df_conteo = pd.DataFrame({'Rotacion': conteo_comprar.index, 'cantidad': conteo_comprar.values})
df_conteo['Etiqueta'] = df_conteo['Rotacion'].apply(
    lambda x: 'Se Queda (0)' if x == 0 else 'Rota (1)'
)

# Crear el diagrama utilizando Plotly Express
fig = px.bar(
    df_conteo,
    x='Etiqueta', # Usamos la etiqueta para el eje X
    y='cantidad',
    title='Distribuci√≥n del Desbalance de Clases',
    color='Etiqueta', # Asignar color por etiqueta
    color_discrete_map={'Se Queda (0)': '#00ff99', 'Rota (1)': '#ff00aa'} # Mapear los colores ne√≥n
)

# üé® Aplicar Estilo Ne√≥n y Oscuro
fig.update_layout(
    # Fondo y Tema
    template='plotly_dark',
    plot_bgcolor='rgba(0,0,0,0.6)',
    paper_bgcolor='#080014',

    # T√≠tulo (Similar al h1/h2 del CSS)
    title={
        'font': {'color': '#00ffcc', 'size': 24, 'family': 'Orbitron, sans-serif'},
        'x': 0.5, # Centrar
        'xanchor': 'center'
    },

    # Ejes
    xaxis={
        'title': {'text': 'Clase de Rotaci√≥n', 'font': {'color': '#00ff99'}},
        'tickfont': {'color': '#f5f5f5'},
        'gridcolor': '#1a1a1a'
    },
    yaxis={
        'title': {'text': 'Cantidad de Empleados', 'font': {'color': '#ff00aa'}},
        'tickfont': {'color': '#f5f5f5'},
        'gridcolor': '#1a1a1a'
    },

    # Leyenda
    legend={
        'title': {'text': 'Clase', 'font': {'color': '#ffb3e6'}},
        'font': {'color': '#f5f5f5'},
        'bgcolor': 'rgba(0,0,0,0.6)',
        'bordercolor': 'rgba(0, 255, 153, 0.44)', # Equivalente a #00ff99 con 44% de opacidad (70 en hex)
        'borderwidth': 1
    }
)

# Personalizar el estilo de las barras para que tengan un borde ne√≥n
fig.update_traces(
    marker_line_color='white', # Borde blanco alrededor de las barras
    marker_line_width=1.5,
    opacity=0.85
)

fig.show()

"""- Hicimos un gr√°fico de barras para ver la distribuci√≥n de la rotaci√≥n.‚Äù
‚ÄúSe observa que la mayor√≠a de empleados se quedan en la empresa (0), mientras que una menor parte la abandona (1).

- Esto muestra un desbalance en las clases, algo importante a tener en cuenta cuando entrenemos el modelo.

- Ahora que entendemos c√≥mo est√° distribuida la variable objetivo, pasamos a preparar el set de entrenamiento y prueba.

###Simplificaci√≥n de columnas para que el EDA sea m√°s enfocado en la variable objetivo (Rotaci√≥n) y, de paso, preparamos mejor los datos para el modelo.

####Dropssss
"""

import numpy as np

# 1) quitar columnas poco √∫tiles
cols_drop = ["Numero_Empleado", "Conteo_Empleados", "Mayor_18", "Horas_Estandar"]
cols_drop = [c for c in cols_drop if c in df.columns]
df = df.drop(columns=cols_drop)

# 2) transformar ingreso mensual
if 'Ingreso_Mensual' in df.columns:
    df['log_Ingreso_Mensual'] = np.log1p(df['Ingreso_Mensual'])

# 3) agrupar Rol_Laboral
if 'Rol_Laboral' in df.columns:
    mapa_roles = {
        'Sales Executive':'Ventas', 'Sales Representative':'Ventas',
        'Research Scientist':'Investigacion', 'Laboratory Technician':'Investigacion',
        'Manufacturing Director':'Manufactura', 'Healthcare Representative':'Soporte',
        'Manager':'Direccion', 'Research Director':'Direccion',
        'Human Resources':'RRHH'
    }
    df['Rol_Laboral_agrupado'] = df['Rol_Laboral'].map(mapa_roles).fillna('Otros')

# 4) listas finales para gr√°ficos
cols_num = [c for c in [
    'Edad', 'log_Ingreso_Mensual', 'Distancia_Hogar',
    'Anios_Experiencia_Total', 'Anios_Puesto_Actual', 'Anios_Empresa'
] if c in df.columns]

cols_cat = [c for c in [
    'Horas_Extra', 'Estado_Civil', 'Genero',
    'Rol_Laboral_agrupado', 'Balance_Vida_Trabajo', 'Satisfaccion_Trabajo'
] if c in df.columns]

"""- Eliminamos columnas poco √∫tiles como n√∫mero de empleado o mayor de 18.

- Transformamos el ingreso mensual con logaritmo para que la distribuci√≥n sea m√°s clara.

- Agrupamos los roles laborales en categor√≠as m√°s simples: ventas, investigaci√≥n, direcci√≥n, soporte, etc.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Num√©ricas
n = len(cols_num)
rows = (n + 2) // 3
fig, axes = plt.subplots(rows, 3, figsize=(18, 5*rows))
axes = axes.flatten()

for i, col in enumerate(cols_num):
    axes[i].hist(df[col].dropna(), bins=20, color='magenta', edgecolor='cyan')
    axes[i].set_title(f'Distribuci√≥n de {col.replace("_", " ").lower()}'.capitalize())

for j in range(i+1, len(axes)):
    fig.delaxes(axes[j])

plt.suptitle("Distribuci√≥n de variables num√©ricas seleccionadas", fontsize=16, weight="bold")
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

# Categ√≥ricas
m = len(cols_cat)
rows = (m + 2) // 3
fig, axes = plt.subplots(rows, 3, figsize=(18, 5*rows))
axes = axes.flatten()

for i, col in enumerate(cols_cat):
    order = sorted(df[col].dropna().unique(), key=lambda x: x) if df[col].dtype == 'O' else None
    sns.countplot(x=df[col], ax=axes[i], palette="viridis", order=order)
    axes[i].set_title(f'Distribuci√≥n de {col.replace("_", " ").lower()}'.capitalize())
    axes[i].tick_params(axis='x', rotation=35)

for j in range(i+1, len(axes)):
    fig.delaxes(axes[j])

plt.suptitle("Distribuci√≥n de variables categ√≥ricas seleccionadas", fontsize=16, weight="bold")
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

"""##Resultados de los gr√°ficos

**Variables num√©ricas:**

- La edad se concentra entre 30 y 40 a√±os.

- Los ingresos muestran mucha variabilidad, con mayor concentraci√≥n en rangos medios.

- La mayor√≠a vive cerca de la empresa (distancia baja).
Los a√±os de experiencia y permanencia tienden a ser pocos: muchos empleados con menos de 10 a√±os.

**Variables categ√≥ricas:**

- M√°s empleados trabajan sin horas extra que con ellas.

- Estado civil: predominan los casados, seguidos de solteros y divorciados.
G√©nero: ligera mayor√≠a de hombres.

- Rol laboral: destacan investigaci√≥n y ventas.

- Balance vida-trabajo: la mayor√≠a lo eval√∫a como ‚Äú3‚Äù (medio).

- Satisfacci√≥n en el trabajo: se concentra en valores medios-altos (3 y 4).

###Creamos variables compuestas ‚Äú√∫tiles para el modelo‚Äù, eliminamos columnas redundantes y creamos un **df_modelo**
"""

import numpy as np
import pandas as pd

df = df.copy()

# Compensaci√≥n en escala log (m√°s estable ante asimetr√≠as)
if 'Ingreso_Mensual' in df.columns:
    df['log_Ingreso_Mensual'] = np.log1p(df['Ingreso_Mensual'])

# Satisfacci√≥n compuesta: promedio simple de escalas disponibles
cols_satis = [c for c in df.columns if c.lower().startswith('satisfaccion')]
if cols_satis:
    df['Satisfaccion_Global'] = df[cols_satis].mean(axis=1)

# Balance de vida-trabajo normalizado a 0‚Äì1 (si escala 1‚Äì4)
if 'Balance_Vida_Trabajo' in df.columns:
    max_bal = df['Balance_Vida_Trabajo'].max()
    df['Balance_Normalizado'] = (df['Balance_Vida_Trabajo'] - 1) / (max_bal - 1) if max_bal > 1 else df['Balance_Vida_Trabajo']

# Distancia capada para outliers extremos (winsor 99%)
if 'Distancia_Hogar' in df.columns:
    p99 = df['Distancia_Hogar'].quantile(0.99)
    df['Distancia_capped'] = np.minimum(df['Distancia_Hogar'], p99)

"""- Generamos nuevas variables compuestas enriquecen el dataset y ayudan al modelo a detectar patrones m√°s claros sobre la rotaci√≥n de empleados.

####Dropssss
"""

# Definir columnas a descartar (IDs, constantes o redundantes)
cols_drop = [c for c in [
    'Ingreso_Mensual','Distancia_Hogar','Rol_Laboral',
    'Satisfaccion_Entorno','Satisfaccion_Trabajo','Satisfaccion_Relaciones'  # reemplazadas por derivadas
] if c in df.columns]

df_limpio = df.drop(columns=cols_drop)

target = 'Rotacion'

cols_num = [c for c in [
    'Edad','Anios','Anios_Empresa','Anios_Puesto_Actual',
    'log_Ingreso_Mensual','Distancia_capped','Satisfaccion_Global','Balance_Normalizado'
] if c in df_limpio.columns]

cols_cat = [c for c in [
    'Estado_Civil','Genero','Rol_Laboral_agrupado','Horas_Extra',
    'Balance_Vida_Trabajo','Satisfaccion_Trabajo'
] if c in df_limpio.columns]

cols_modelo = [c for c in (cols_num + cols_cat + [target]) if c in df_limpio.columns]
df_modelo = df_limpio[cols_modelo].copy()

# Resumen num√©rico
print(df_modelo.select_dtypes(include=np.number).describe().T)

# Conteo de la variable objetivo (balance de clases)
if target in df_modelo.columns:
    print("\nDistribuci√≥n de la variable objetivo:")
    print(df_modelo[target].value_counts(normalize=True).rename('proporcion').to_frame())

df_modelo.describe()

"""- Eliminamos columnas redundantes, como las originales de ingreso o satisfacci√≥n, porque ya ten√≠amos sus versiones derivadas.

- Definimos las variables num√©ricas y categ√≥ricas que van a entrar en el modelo, junto con la variable objetivo: Rotaci√≥n.

- Creamos un dataset limpio (df_modelo) con solo las variables √∫tiles para entrenar.


**Resumen estad√≠stico**

- La edad promedio es de 37 a√±os, la mayor√≠a con menos de 10 a√±os en la empresa y menos de 5 en su puesto actual.

- El balance vida-trabajo y la satisfacci√≥n global se concentran en valores intermedios.

- La variable objetivo confirma el desbalance: 84% se queda, 16% se va.

üëâ Conclusi√≥n:
 - Ya tenemos un dataset compacto, limpio y con variables relevantes, listo para entrenar los modelos predictivos.

#Implementaci√≥n del algoritmo Bayes

Selecci√≥n de variables con **SelectKBest**: Preprocesamos (imputa y codifica dummies), calculamos relevancia univariante contra Rotacion con mutual_info_classif y devolvemos las k mejores features (incluye dummies de categ√≥ricas).
"""

from sklearn.model_selection import train_test_split
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.feature_selection import SelectKBest, mutual_info_classif
import numpy as np

# Definiciones

target = 'Rotacion'
X = df_modelo.drop(columns=[target]).copy()
y = df_modelo[target].astype('category').cat.codes  # codificamos target

# Separar variables num√©ricas y categ√≥ricas
num_vars = X.select_dtypes(include=np.number).columns.tolist()
cat_vars = X.select_dtypes(exclude=np.number).columns.tolist()


# Preprocesamiento
# Pipeline num√©rico
num_pipe = Pipeline([
    ('imputer', SimpleImputer(strategy='median'))
])

# Pipeline categ√≥rico con OneHotEncoder
cat_pipe = Pipeline([
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('ohe', OneHotEncoder(handle_unknown='ignore'))
])

# ColumnTransformer que une todo
pre = ColumnTransformer([
    ('num', num_pipe, num_vars),
    ('cat', cat_pipe, cat_vars)
])

# Selecci√≥n de features

k = 12  # n√∫mero de features a conservar

sel_pipe = Pipeline([
    ('pre', pre),
    ('sel', SelectKBest(score_func=mutual_info_classif, k=k))
])

# Fit y transformaci√≥n
X_sel = sel_pipe.fit_transform(X, y)

# Recuperar nombres de features seleccionadas
# Nombres de num√©ricas
num_names = np.array(num_vars)

# Nombres de categ√≥ricas (OneHotEncoder)
ohe = sel_pipe.named_steps['pre'].named_transformers_['cat'].named_steps['ohe'] if len(cat_vars) > 0 else None
cat_names = ohe.get_feature_names_out(cat_vars) if ohe is not None else np.array([])

# Concatenamos nombres
feature_names = np.r_[num_names, cat_names]

# M√°scara de seleccionadas
mask = sel_pipe.named_steps['sel'].get_support()
features_top = feature_names[mask]

print(f"Top {k} variables seleccionadas:\n", features_top)

"""- Aplicamos un proceso de preprocesamiento: imputai√≥n de valores faltantes, codificaci√≥n de variables categ√≥ricas y escalado.

- Usamos SelectKBest con informaci√≥n mutua para quedarnos con las 12 variables m√°s importantes.

- Entre ellas aparecen: Edad, A√±os en la empresa, A√±os en el puesto, Ingreso logar√≠tmico, Satisfacci√≥n global, Balance vida-trabajo y Horas Extra.‚Äù
‚ÄúTambi√©n influyen caracter√≠sticas personales como el estado civil y el rol laboral.

- Con estas 12 variables clave ya tenemos un dataset optimizado y listo para entrenar modelos de predicci√≥n de rotaci√≥n.

Mapa de calor de correlaci√≥n de Pearson
"""

# Correlaci√≥n entre num√©ricas del df_modelo
numericas_disponibles = df_modelo.select_dtypes(include=np.number).drop(columns=[target], errors='ignore')
plt.figure(figsize=(10,8))
sns.heatmap(numericas_disponibles.corr(), annot=True, fmt=".2f",
            cmap=plt.cm.Spectral, linewidths=0.1, linecolor='white', square=True)
plt.title("Correlaci√≥n de Pearson entre variables num√©ricas")
plt.tight_layout()
plt.show()

"""- Calculamos la correlaci√≥n de Pearson entre variables num√©ricas para detectar relaciones fuertes.

- Vemos que los a√±os en la empresa y los a√±os en el puesto actual est√°n muy correlacionados.

- Tambi√©n hay correlaci√≥n moderada entre ingreso y antig√ºedad (0.49‚Äì0.51).

- Las dem√°s variables muestran baja correlaci√≥n, lo que significa que cada una aporta informaci√≥n distinta al modelo.
"""

# Histogramas de num√©ricas m√°s relevantes
usadas_num = [c for c in ['Edad','Anios_Empresa','Anios_Puesto_Actual',
                          'log_Ingreso_Mensual','Distancia_capped',
                          'Ratio_Antiguedad_Puesto']
              if c in numericas_disponibles.columns]

df_modelo[usadas_num].hist(color='blue', edgecolor='cyan', figsize=(12,8), bins=20)
plt.show()

"""- Estos histogramas nos muestran que la mayor√≠a de empleados son j√≥venes, llevan pocos a√±os en la empresa y suelen vivir cerca, lo cual influye en los patrones de rotaci√≥n.

- Edad: se concentra entre 30 y 40 a√±os.

- A√±os en la empresa y a√±os en el puesto actual: la mayor√≠a tiene poca antig√ºedad (menos de 10 a√±os).

- Ingreso mensual logar√≠tmico: distribuido en rangos medios, sin valores extremos tan marcados.

- Distancia al hogar: la mayor√≠a vive muy cerca de la empresa.

- Ratio antig√ºedad-puesto: muchos empleados est√°n relativamente poco tiempo en el puesto en comparaci√≥n con su permanencia total.

Split y Pipeline de Naive Bayes
"""

import numpy as np
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score, RocCurveDisplay
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import FunctionTransformer
from sklearn.feature_selection import SelectKBest, mutual_info_classif
from sklearn.model_selection import train_test_split

# Semilla
np.random.seed(42)

# Train/Test
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.25, random_state=42, stratify=y
)

# Pipeline completo (pre + select k + denso + NB)
to_dense = FunctionTransformer(lambda A: A.toarray() if hasattr(A,"toarray") else A)

#---------------------------
#BALANCEO CON SMOTE PARA NB!!
#---------------------------
nb_smote= ImbPipeline([
    ('pre', pre),
    ('smote', SMOTE(random_state=42)), # PASO DE BALANCEO
    ('sel', SelectKBest(
        score_func=lambda X, y: mutual_info_classif(X, y, random_state=42),
        k=k
    )),
    ('to_dense', to_dense),
    ('clf', GaussianNB())
])

nb_smote.fit(X_train, y_train) # SE ENTRENA CON EL NUEVO PIPELINE

y_pred = nb_smote.predict(X_test)
y_prob = nb_smote.predict_proba(X_test)[:,1]

# Evaluaci√≥n
print("Evaluando Naive Bayes SMOTE...")
res_nb = evalua_modelo(nb_smote, 'Naive Bayes SMOTE')
print(f"NB SMOTE F1(1): {res_nb['f11']:.3f}")

print("Reporte de clasificaci√≥n:\n", classification_report(y_test, y_pred, digits=3))
print("ROC AUC:", roc_auc_score(y_test, y_prob))
# Evaluaci√≥n

# Matriz de confusi√≥n (versi√≥n seaborn)
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(4,3))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title('Matriz de confusi√≥n - Naive Bayes')
plt.xlabel('Predicci√≥n'); plt.ylabel('Real')
plt.tight_layout(); plt.show()

"""- Dividimos los datos en train (75%) y test (25%), aplicando un pipeline completo con preprocesamiento, selecci√≥n de variables y Naive Bayes.

- El modelo alcanz√≥ una accuracy de 79,6% y un ROC AUC de 0.75, lo que indica un buen poder de discriminaci√≥n.

**M√©tricas principales:**

Clase 0 (se queda): alta precisi√≥n (0.93) y buen recall (0.81).

Clase 1 (se va): precisi√≥n baja (0.41) pero recall aceptable (0.69), lo que significa que el modelo logra detectar a una parte importante de quienes se van, aunque con falsos positivos.

F1-score de la clase 1: 0.51, muestra espacio de mejora.


**Matriz de confusi√≥n:**

252 Personas que realmente se quedaron en la empresa y el modelo predijo

57 Personas que realmente se quedaron en la empresa, pero el modelo predijo ‚Äúabandona‚Äù (falsos positivos).correctamente ‚Äúse queda‚Äù.

18 Personas que realmente abandonaron la empresa, pero el modelo predijo ‚Äúse queda‚Äù (falsos negativos).

41 Personas que realmente abandonaron la empresa y el modelo predijo correctamente ‚Äúabandona‚Äù.


üëâ Conclusi√≥n del modelo:
El Naive Bayes es capaz de capturar un patr√≥n claro en la rotaci√≥n, con buena capacidad para identificar a empleados que se quedan, aunque a√∫n con margen de mejora en la predicci√≥n de quienes abandonan la empresa.

# ¬øMejora del modelo subiendo el recall y bajando el umbral?
"""

from sklearn.metrics import precision_recall_curve, classification_report, confusion_matrix
import numpy as np

probs = nb_smote.predict_proba(X_test)[:,1]
p, r, th = precision_recall_curve(y_test, probs)

# umbral que maximiza F2 (prioriza recall)
f2 = (1+2**2)*(p*r)/((2**2)*p + r + 1e-9)
thr = th[np.nanargmax(f2)]
y_pred_thr = (probs >= thr).astype(int)

print("Umbral F2:", round(float(thr),4))
print(classification_report(y_test, y_pred_thr, digits=3))
print(confusion_matrix(y_test, y_pred_thr))

import plotly.graph_objects as go
from sklearn.metrics import confusion_matrix

cm = confusion_matrix(y_test, y_pred_thr, labels=[0,1])

fig = go.Figure(data=go.Heatmap(
    z=cm,
    x=['Predijo: No rotaci√≥n','Predijo: Rotaci√≥n'],
    y=['Real: No rotaci√≥n','Real: Rotaci√≥n'],
    colorscale='Blues',
    text=cm,
    texttemplate="%{text}",
    showscale=True
))
fig.update_layout(
    title='Matriz de confusi√≥n - Naive Bayes (umbral F2)',
    xaxis_title='Predicci√≥n',
    yaxis_title='Real',
    autosize=False, width=650, height=420
)
fig.show()

"""Si, seg√∫n el objetivo que planteamos...

Al ser nuestro objetivo no perder renuncias (maximizar recall de la clase 1): mejora. Subimos el recall de 0.69 ‚Üí 0.76 (detectamos m√°s gente que se va).

Pero tambi√©n baja la precisi√≥n (0.418 ‚Üí 0.402) y la accuracy (0.79 ‚Üí 0.78). La precisi√≥n/accuracy no mejora; el modelo dispara m√°s falsos positivos.

Pero viendo los numeros, el accuracy y presicion no tiene un cambio muy drastico entonces esto parece estar mejor con el cambio.

**En conclusion**

Si mejora en terminos de recall, ahora perdemos menos abandonos de empleados **14 vs 18**

El costo seria que la empresa se preocupar√° por m√°s falsos positivos **67 empleados que no se iban a ir, pero el modelo creyo que habia riesgo de abandono**

En el contexto dde RRHH, esto puede ser lo mas aceptable, **mejor invertir en retener a empleados que no se iban a ir, que perder talento para la empresa por no haberlo detectado**

## **BALANCEO Y OPTIMIZACI√ìN DE MODELOS FALTANTES (SMOTE)**
Para asegurar que todos los modelos base del Stacking Classifier (RL, RF, NB) usen SMOTE antes de que el Stacking los combine.

Funciones de evaluacion modelo RF y RL

- def umbral_f1:
Cuando un modelo calcula una probabilidad de rotaci√≥n (ej. $0.35$), necesita una regla de decisi√≥n para convertir esa probabilidad en una predicci√≥n binaria ($0$ o $1$). Estos usan un **umbral estandar (0.5)**. Esta funcion encuentra el punto de corte optimo que maximiza el rendimiento del modelo, especifica para la clase minoritaria (rotacion).
"""

cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

# Umbral F1
def umbral_f1(probs, y_true):
    p, r, th = precision_recall_curve(y_true, probs)
    if th.size == 0:
        return 0.5
    f1 = 2 * p[1:] * r[1:] / (p[1:] + r[1:] + 1e-9)
    return th[np.nanargmax(f1)]

# Funci√≥n de Evaluaci√≥n
def evalua_modelo(pipe, nombre):
    pipe.fit(X_train, y_train)
    probs = pipe.predict_proba(X_test)[:,1]
    thr = umbral_f1(probs, y_test)
    y_pred = (probs >= thr).astype(int)

    # m√©tricas
    auc = roc_auc_score(y_test, probs)
    acc = accuracy_score(y_test, y_pred)
    # precision/recall/F1 de la clase 1 desde el reporte
    rep = classification_report(y_test, y_pred, output_dict=True)
    prec1 = rep['1']['precision']; rec1 = rep['1']['recall']; f11 = rep['1']['f1-score']

    # curva ROC
    fpr, tpr, _ = roc_curve(y_test, probs)

    return {
        'nombre': nombre, 'pipe': pipe, 'probs': probs, 'thr': thr,
        'auc': auc, 'acc': acc, 'prec1': prec1, 'rec1': rec1, 'f11': f11,
        'fpr': fpr, 'tpr': tpr
    }

# Helper para Naive Bayes
to_dense = FunctionTransformer(lambda A: A.toarray() if hasattr(A, "toarray") else A)

# ----------------------------------------------------------------------
# 2. Definici√≥n y Optimizaci√≥n de Regresi√≥n Log√≠stica con SMOTE
# ----------------------------------------------------------------------

# Pipeline de Regresi√≥n Log√≠stica con SMOTE
smote_logit = ImbPipeline([
    ('pre', pre),
    ('smote', SMOTE(random_state=42)),
    ('clf', LogisticRegression(max_iter=1000, solver='lbfgs', random_state=42))
])

# GridSearch para Log√≠stica
print("Iniciando GridSearch de Regresi√≥n Log√≠stica (SMOTE)...")
grid_logit = {'clf__C': [0.1, 0.5, 1, 2]}
gs_log = GridSearchCV(smote_logit, grid_logit, scoring='f1', cv=cv, n_jobs=-1)
gs_log.fit(X_train, y_train)
best_log = gs_log.best_estimator_
print(f"Mejor C para Log√≠stica (SMOTE): {gs_log.best_params_['clf__C']}")

# Evaluaci√≥n
res_log = evalua_modelo(best_log, 'Regresi√≥n Log√≠stica SMOTE')
print(f"RL SMOTE F1(1): {res_log['f11']:.3f}")

# ----------------------------------------------------------------------
# 3. Definici√≥n y Optimizaci√≥n de Random Forest con SMOTE
# ----------------------------------------------------------------------

# Pipeline de Random Forest con SMOTE
smote_rf = ImbPipeline([
    ('pre', pre),
    ('smote', SMOTE(random_state=42)),
    ('clf', RandomForestClassifier(random_state=42, n_jobs=-1))
])

# GridSearch para Random Forest
print("\nIniciando GridSearch de Random Forest (SMOTE)...")
grid_rf = {
    'clf__n_estimators': [300, 500],
    'clf__max_depth': [10, None],
    'clf__min_samples_leaf': [1, 2, 4],
}
gs_rf = GridSearchCV(smote_rf, grid_rf, scoring='f1', cv=cv, n_jobs=-1)
gs_rf.fit(X_train, y_train)
best_rf = gs_rf.best_estimator_
print(f"Mejores par√°metros para RF (SMOTE): {gs_rf.best_params_}")

# Evaluaci√≥n
res_rf = evalua_modelo(best_rf, 'Random Forest SMOTE')
print(f"RF SMOTE F1(1): {res_rf['f11']:.3f}")

"""**Como nos sugirio el profe implemente ''SMOTE'', una t√©cnica de sobremuestreo sintetico de la clase minoritaria. Smote es un algoritmo de sobremuestreo muy util para abordar problemas de desbalance de clases. Esto lo resuelve creando nuevas instancias sinteticas para la clase minoritaria.**

FUNCIONAMIENTO:
- Para cada instancia $x_i$ de la clase minoritaria, SMOTE encuentra sus $k$ vecinos m√°s cercanos (utilizando, por ejemplo, la distancia Euclidiana) dentro de la misma clase minoritaria.
- Selecciona aleatoriamente uno de estos $k$ vecinos m√°s cercanos ($x_{zn}$).
- Genera un nuevo ejemplo sint√©tico.

**Este proceso ayuda a que el conjunto de datos se vuelva m√°s balanceado, lo que permite que el modelo aprenda mejor las caracter√≠sticas de la clase minoritaria y mejore su rendimiento general.**

SMOTE se implementa dentro de ImbPipeline, una version especializada de Pipeline. Si intentaramos usar el Pipeline est√°ndar de scikit-learn para integrar SMOTE, podr√≠amos encontrarnos con un Data Leakage, porque aplicariamos SMOTE a todo el conjunto de datos de entrenamiento antes de la validaci√≥n cruzada, los ejemplos sint√©ticos creados se basar√≠an en informaci√≥n tanto del fold de entrenamiento como del fold de validaci√≥n. Esto sobreestima el rendimiento real del modelo porque el clasificador ya ha "visto" informaci√≥n de los datos de validaci√≥n a trav√©s de los ejemplos sint√©ticos.

#**Stacking Classifier**
"""

# @title
# ----------------------------------------------------------------------
# 4. Implementaci√≥n del Stacking Classifier
# ----------------------------------------------------------------------
print("\n--- STACKING CLASSIFIER (Modelos Base: SMOTE) ---")

# Definici√≥n de Estimadores Base (los tres modelos optimizados con SMOTE)
estimators_smote = [
    ('log', best_log),
    ('rf', best_rf),
    ('nb', nb_smote)
]

# Creaci√≥n y Evaluaci√≥n del Stacking Classifier
stacking_pipe_smote = StackingClassifier(
    estimators=estimators_smote,
    final_estimator=LogisticRegression(solver='lbfgs', max_iter=1000, random_state=42),
    cv=cv,
    n_jobs=-1
)

print("Evaluando Stacking Classifier...")
res_stacking_smote = evalua_modelo(stacking_pipe_smote, 'Stacking (SMOTE)')


# ----------------------------------------------------------------------
# 5. Resumen FINAL
# ----------------------------------------------------------------------

# Recopilamos todos los resultados
todos_los_resultados_smote = [res_nb, res_log, res_rf, res_stacking_smote]

resumen_final_smote = pd.DataFrame([
    {'Modelo': r['nombre'], 'AUC': r['auc'], 'Precisi√≥n(1)': r['prec1'],
     'Recall(1)': r['rec1'], 'F1(1)': r['f11'], 'Accuracy': r['acc'], 'Umbral F1': r['thr']}
    for r in todos_los_resultados_smote
]).sort_values('AUC', ascending=False)


print("\n### üëë Resumen FINAL de M√©tricas (SMOTE + Stacking) ###")
print(resumen_final_smote.round(3))

# @title

# --- ESTILOS DE TABLA NE√ìN ---
HTML_STYLE = '''
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;500&display=swap');

.neon-table {
    border-collapse: separate;
    border-spacing: 0;
    width: 100%;
    margin: 20px 0;
    font-family: 'Poppins', sans-serif;
    color: #f5f5f5;
    box-shadow: 0 0 20px rgba(0, 255, 153, 0.5), 0 0 10px rgba(255, 0, 170, 0.5);
    border-radius: 10px;
    overflow: hidden; /* Para que el border-radius funcione */
}

.neon-table th, .neon-table td {
    padding: 12px 15px;
    text-align: center;
    border-bottom: 1px solid rgba(0, 255, 153, 0.3);
}

.neon-table th {
    background-color: rgba(255, 0, 170, 0.2); /* Fondo rosa oscuro */
    color: #00ff99; /* Texto cian ne√≥n */
    text-transform: uppercase;
    font-size: 0.9em;
    font-weight: 700;
    letter-spacing: 1px;
    border-top: 2px solid #00ff99;
}

.neon-table tr:nth-child(even) {
    background-color: rgba(0, 0, 0, 0.4);
}

.neon-table tr:nth-child(odd) {
    background-color: rgba(10, 0, 15, 0.5);
}

.neon-table tr:hover {
    background-color: rgba(255, 0, 170, 0.1);
}

.neon-table .auc-column {
    color: #ffb3e6; /* Rosa brillante para la m√©trica clave */
    font-weight: bold;
    text-shadow: 0 0 5px #ff00aa;
}

.neon-header {
    text-align: center;
    font-size: 2.0em;
    color: #00ffcc;
    text-shadow: 0 0 15px #00ff99aa;
    font-family: 'Orbitron', sans-serif;
    margin-top: 30px;
    margin-bottom: 15px;
}
</style>
'''

def display_neon_dataframe(df, title):
    """Muestra un DataFrame con el estilo ne√≥n."""
    html_output = HTML_STYLE
    html_output += f'<div class="neon-header">üëë {title} üëë</div>'

    # Aplicar clase CSS a las celdas de la columna AUC
    styled_df = df.style.set_table_attributes('class="neon-table"')

    # Enfatizar la columna AUC
    styled_df = styled_df.apply(
        lambda x: ['background-color: rgba(0, 255, 153, 0.15)' if x.name == 'AUC' else '' for i in x], axis=1
    )

    # Renderizar el DataFrame a HTML
    html_output += styled_df.to_html(classes='neon-table', index=False, float_format="%.3f")
    display(HTML(html_output))


# ----------------------------------------------------------------------
# 4. Implementaci√≥n del Stacking Classifier (Parte Funcional)
# ----------------------------------------------------------------------
print("\n--- STACKING CLASSIFIER (Modelos Base: SMOTE) ---")

# NOTA: Esta secci√≥n requiere que las variables de tu entorno (best_log, best_rf, etc.) est√©n definidas.
try:
    # Definici√≥n de Estimadores Base (los tres modelos optimizados con SMOTE)
    estimators_smote = [
        ('log', best_log),
        ('rf', best_rf),
        ('nb', nb_smote)
    ]

    # Creaci√≥n y Evaluaci√≥n del Stacking Classifier
    stacking_pipe_smote = StackingClassifier(
        estimators=estimators_smote,
        final_estimator=LogisticRegression(solver='lbfgs', max_iter=1000, random_state=42),
        cv=cv,
        n_jobs=-1
    )

    print("Evaluando Stacking Classifier...")
    res_stacking_smote = evalua_modelo(stacking_pipe_smote, 'Stacking (SMOTE)')

    # ----------------------------------------------------------------------
    # 5. Resumen FINAL (Parte de Visualizaci√≥n)
    # ----------------------------------------------------------------------

    # Recopilamos todos los resultados
    todos_los_resultados_smote = [res_nb, res_log, res_rf, res_stacking_smote]

    resumen_final_smote = pd.DataFrame([
        {'Modelo': r['nombre'], 'AUC': r['auc'], 'Precisi√≥n(1)': r['prec1'],
         'Recall(1)': r['rec1'], 'F1(1)': r['f11'], 'Accuracy': r['acc'], 'Umbral F1': r['thr']}
        for r in todos_los_resultados_smote
    ]).sort_values('AUC', ascending=False).round(3)


    # Reemplazo del print() por la funci√≥n de visualizaci√≥n HTML
    display_neon_dataframe(resumen_final_smote, "Resumen FINAL de M√©tricas (SMOTE + Stacking)")

except NameError as e:
    # Este bloque solo se ejecuta si faltan las variables de entorno necesarias (como 'best_log')
    print("\n--- ERROR DE EJECUCI√ìN ---")
    print(f"El c√≥digo funcional no pudo ejecutarse porque faltan variables clave como 'best_log', 'evalua_modelo', o 'cv'.")
    print("El c√≥digo HTML para el DataFrame se ha definido correctamente, pero necesitas ejecutar las celdas anteriores.")

    # Mostrar un DataFrame de ejemplo con el estilo HTML
    ejemplo_data = {
        'Modelo': ['Regresi√≥n Log√≠stica SMOTE', 'Stacking (SMOTE)', 'Random Forest SMOTE', 'Naive Bayes SMOTE'],
        'AUC': [0.805, 0.803, 0.784, 0.774],
        'Precisi√≥n(1)': [0.522, 0.547, 0.517, 0.443],
        'Recall(1)': [0.610, 0.593, 0.508, 0.593],
        'F1(1)': [0.562, 0.569, 0.513, 0.507],
        'Accuracy': [0.848, 0.856, 0.845, 0.815],
        'Umbral F1': [0.640, 0.278, 0.359, 0.716]
    }
    ejemplo_df = pd.DataFrame(ejemplo_data).sort_values('AUC', ascending=False).round(3)
    display_neon_dataframe(ejemplo_df, "EJEMPLO: Resumen FINAL de M√©tricas (SMOTE + Stacking)")

# @title
from IPython.display import HTML

HTML('''
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;500&display=swap');

/* Estilos de fondo y texto generales */
.conclusion-container {
    max-width: 900px;
    margin: 40px auto;
    background: linear-gradient(160deg, rgba(5,0,15,0.95), rgba(0, 0, 0, 0.9));
    border-radius: 20px;
    padding: 30px 40px;
    /* Borde ne√≥n pulsante */
    box-shadow: 0 0 25px #ff00aa80, 0 0 45px #00ff9980;
    border: 2px solid #00ff99;
    color: #f5f5f5;
    font-family: 'Poppins', sans-serif;
    line-height: 1.6;
}

/* Encabezado principal */
.conclusion-container h3 {
    text-align: center;
    font-size: 2.2em;
    font-family: 'Orbitron', sans-serif;
    color: #00ff99;
    text-shadow: 0 0 15px #00ff99aa, 0 0 20px #ff00aa80;
    margin-bottom: 25px;
    padding-bottom: 10px;
    border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
}

/* P√°rrafo de justificaci√≥n principal */
.justification {
    font-size: 1.1em;
    margin-top: 20px;
    border-left: 5px solid #ff00aa;
    padding-left: 15px;
    background: rgba(255, 0, 170, 0.08);
    border-radius: 5px;
    padding: 15px;
}

/* Resumen de m√©tricas */
.metrics-section {
    margin-top: 30px;
    padding: 20px;
    border: 1px solid rgba(0, 255, 153, 0.4);
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.5);
}

.metrics-section strong {
    color: #ff00aa;
    text-shadow: 0 0 5px #ff00aa;
    font-size: 1.1em;
}

/* Puntos de m√©tricas */
.metrics-section ul {
    list-style-type: none;
    padding-left: 0;
}

.metrics-section li {
    margin-bottom: 10px;
    padding-left: 20px;
    position: relative;
}

.metrics-section li::before {
    content: "üî∏";
    position: absolute;
    left: 0;
    color: #00ff99;
}

/* Resaltado de valores num√©ricos */
.highlight-value {
    color: #00ff99;
    font-weight: 700;
    text-shadow: 0 0 8px #00ff9980;
}

/* √ânfasis en el costo del error */
.cost-emphasis {
    color: #ffb3e6;
    font-weight: bold;
    font-style: italic;
}
</style>

<div class="conclusion-container">
    <h3>üëë Gana el modelo Regresi√≥n Log√≠stica üëë</h3>

    <p>Probamos cuatro modelos y el modelo de <strong class="highlight-value">Regresi√≥n Log√≠stica (RL)</strong> fue el que mejores resultados mostr√≥. Este logra el mejor AUC, lo que indica una mayor capacidad para distinguir entre empleados que rotan y los que no. El Stacking Classifier le sigue de cerca con un AUC de <span class="highlight-value">0.803</span>.</p>

    <div class="metrics-section">
        <strong>(F1 y Recall):</strong> El objetivo de identificar la rotaci√≥n es crucial porque la clase de inter√©s (empleado que se va [1]) es la minoritaria y la m√°s costosa al fallar.

        <ul>
            <li>
                <strong>RL:</strong> Con un Recall de <span class="highlight-value">0.610</span>, este modelo es mejor para "atrapar" a los empleados que realmente rotar√°n. Es decir, tiene una tasa m√°s baja de Falsos Negativos. Su enfoque est√° en no perderse casos de rotaci√≥n, incluso si esto significa equivocarse un poco m√°s a menudo (Precisi√≥n baja de 0.522).
            </li>
            <li>
                <strong>SC:</strong> Aunque su Recall es ligeramente menor (<span class="highlight-value">0.593</span>), su Precisi√≥n (0.547) es mejor. Esto significa que cuando este modelo predice que alguien rotar√°, es m√°s probable que esa predicci√≥n sea correcta. Ofrece el F1-Score m√°s alto (0.569) porque mejora la fiabilidad de las predicciones positivas, logrando un balance general √≥ptimo.
            </li>
        </ul>
    </div>

    <hr style="border-top: 1px dashed rgba(255, 255, 255, 0.2); margin: 25px 0;">

    <p class="justification">
        Si bien el Stacking Classifier (SC) tuvo el F1-Score m√°s alto (<span class="highlight-value">0.569</span>), mi conclusi√≥n es que la <strong class="highlight-value">Regresi√≥n Log√≠stica (RL)</strong> es el modelo m√°s valioso para el objetivo de negocio.
    </p>

    <p class="justification">
        En el contexto de la rotaci√≥n de empleados, el error m√°s costoso es el <span class="cost-emphasis">Falso Negativo (FN)</span>. Un FN es cuando el modelo predice que un empleado se queda [0], pero en realidad se va [1]. Si fallamos en predecir que alguien de alto potencial se ir√°, <span class="cost-emphasis">perdemos la oportunidad de intervenir (ofrecer un aumento, un nuevo rol, etc.).</span>
    </p>
</div>
''')

"""# **Monetizacion del modelo ganadorüí∞**

"""

#Definimos la matriz de Costos y Beneficios (C)
#Filas: Real (0, 1), Columnas: Predicci√≥n (0, 1)
C_costo=np.array([
    [0, -1000], # Fila 0 (Real=0): [VN=0, FP=-1000]
    [-10000, 9000] # Fila 1 (Real=1): [FN=-10000, VP=9000]
])

#Obtenemos los resultados
campeon_res=res_log

#Obtenemos las predicciones del modelo usando su Umbral F1 (0.640)
y_pred_campeon=(campeon_res['probs']>=campeon_res['thr']).astype(int)

# 3. Calcular la Matriz de Confusi√≥n (CM)
CM=confusion_matrix(y_test, y_pred_campeon)

# 4. Calcular el Impacto Econ√≥mico Total (Ganancia)
ganancia_campeon=np.sum(CM * C_costo)

# 5. Calcular el Escenario Base (No acci√≥n / Predice siempre 0)
VN_base=CM[0, 0]+CM[0, 1]  # Total de Real=0
FN_base=CM[1, 0]+CM[1, 1]  # Total de Real=1

# Ganancia Base = (Total No Rotaci√≥n * VN_costo) + (Total Rotaci√≥n * FN_costo)
ganancia_base=(VN_base * C_costo[0, 0])+(FN_base * C_costo[1, 0])

VNC = ganancia_campeon - ganancia_base

print("\n--- Resultados de la Monetizaci√≥n ---")
print(f"Modelo Campe√≥n: {campeon_res['nombre']}")
print(f"Matriz de Confusi√≥n (Regresi√≥n Log√≠stica) - Filas=Real, Col=Pred:\n{CM}")
print(f"Matriz de Costos ($C$) - Filas=Real, Col=Pred:\n{C_costo}")
print("\n--- An√°lisis Econ√≥mico Final ---")
print(f"Ganancia del Modelo Campe√≥n: ${ganancia_campeon:,.2f} USD")
print(f"Ganancia del Escenario Base (No acci√≥n): ${ganancia_base:,.2f} USD")
print(f"Valor Neto de la Clasificaci√≥n (VNC): ${ganancia_campeon - ganancia_base:,.2f} USD")

# @title
# Datos Resultados de la Monetizaci√≥n
nombre_modelo = "Regresi√≥n Log√≠stica SMOTE"
CM_final = np.array([[276, 33], [23, 36]])
C_costo_final = np.array([[0, -1000], [-10000, 9000]])
ganancia_campeon_final = 61000.00
ganancia_base_final = -590000.00
vnc_final = 651000.00

# Formateo de las matrices para visualizaci√≥n HTML
CM_html = pd.DataFrame(CM_final, columns=['Predicci√≥n 0', 'Predicci√≥n 1'], index=['Real 0', 'Real 1']).to_html(classes='matrix-table', header=True, index=True)
Costo_html = pd.DataFrame(C_costo_final, columns=['Predicci√≥n 0', 'Predicci√≥n 1'], index=['Real 0', 'Real 1']).to_html(classes='matrix-table', header=True, index=True, float_format="${:,.0f}".format)


HTML_MONETIZATION = f'''
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;500&display=swap');

.monet-card {{
    max-width: 900px;
    margin: 40px auto;
    background: linear-gradient(145deg, rgba(10, 0, 15, 0.95), rgba(0, 0, 0, 0.9));
    border-radius: 25px;
    padding: 30px;
    box-shadow: 0 0 20px #ff00aa80, 0 0 40px #00ff9980;
    border: 2px solid #ff00aa;
    color: #f5f5f5;
    font-family: 'Poppins', sans-serif;
}}

.monet-header {{
    text-align: center;
    font-size: 2.5em;
    font-family: 'Orbitron', sans-serif;
    color: #00ff99;
    text-shadow: 0 0 15px #00ff99aa, 0 0 20px #ff00aa80;
    margin-bottom: 10px;
    padding-bottom: 15px;
}}

.model-name {{
    text-align: center;
    font-size: 1.4em;
    color: #ffb3e6;
    margin-top: -10px;
    margin-bottom: 30px;
}}

/* Secci√≥n de An√°lisis Econ√≥mico */
.economic-analysis {{
    border: 1px solid rgba(0, 255, 153, 0.4);
    border-radius: 15px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.5);
    margin-top: 25px;
}}

.economic-analysis h4 {{
    text-align: center;
    color: #00ffcc;
    font-family: 'Orbitron', sans-serif;
    margin-top: 0;
}}

.metric-row {{
    display: flex;
    justify-content: space-between;
    padding: 10px 0;
    border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
}}

.metric-row:last-child {{
    border-bottom: none;
    font-size: 1.2em;
    font-weight: bold;
}}

.metric-label {{
    color: #ff00aa;
}}

.metric-value {{
    color: #00ff99;
    font-weight: bold;
    text-shadow: 0 0 8px #00ff9980;
}}

/* Estilo para las tablas de Matriz */
.matrices-section {{
    display: flex;
    justify-content: space-around;
    gap: 20px;
    margin-top: 30px;
    text-align: center;
}}

.matrix-container {{
    flex-basis: 48%;
}}

.matrix-container h5 {{
    color: #ffb3e6;
    font-size: 1.1em;
    margin-bottom: 10px;
}}

.matrix-table {{
    width: 100%;
    border-collapse: collapse;
    background-color: rgba(10, 0, 20, 0.7);
}}

.matrix-table th, .matrix-table td {{
    padding: 10px;
    border: 1px solid rgba(0, 255, 153, 0.3);
    color: #f5f5f5;
}}

.matrix-table th {{
    background-color: rgba(255, 0, 170, 0.2);
    color: #00ff99;
}}
</style>

<div class="monet-card">
    <h1 class="monet-header">Monetizaci√≥n del Modelo Ganador üí∞</h1>
    <h2 class="model-name">Modelo Campe√≥n: {nombre_modelo}</h2>

    <div class="matrices-section">
        <div class="matrix-container">
            <h5>Matriz de Confusi√≥n (CM)</h5>
            {CM_html}
            <small style="color:#ffb3e6;">Filas: Real (0, 1), Columnas: Predicci√≥n (0, 1)</small>
        </div>

        <div class="matrix-container">
            <h5>Matriz de Costos ($C$)</h5>
            {Costo_html}
            <small style="color:#ffb3e6;">Valores: [VN=0, FP=-1000] / [FN=-10000, VP=9000]</small>
        </div>
    </div>

    <div class="economic-analysis">
        <h4>An√°lisis Econ√≥mico Final</h4>

        <div class="metric-row">
            <span class="metric-label">Ganancia del Modelo Campe√≥n:</span>
            <span class="metric-value">${ganancia_campeon_final:,.2f} USD</span>
        </div>

        <div class="metric-row">
            <span class="metric-label">Ganancia del Escenario Base (No Acci√≥n):</span>
            <span class="metric-value">${ganancia_base_final:,.2f} USD</span>
        </div>

        <div class="metric-row" style="border-top: 2px solid #00ff99; margin-top: 15px; padding-top: 15px;">
            <span class="metric-label">Valor Neto de la Clasificaci√≥n (VNC):</span>
            <span class="metric-value">${vnc_final:,.2f} USD</span>
        </div>
    </div>
</div>
'''

display(HTML(HTML_MONETIZATION))

# @title
from IPython.display import HTML

HTML('''
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;500&display=swap');

/* Contenedor principal de la explicaci√≥n */
.monet-expl-card {
    max-width: 900px;
    margin: 40px auto;
    background: linear-gradient(160deg, rgba(15, 0, 30, 0.95), rgba(0, 0, 0, 0.9));
    border-radius: 20px;
    padding: 30px 40px;
    box-shadow: 0 0 20px #00ff9980, 0 0 40px #ff00aa80;
    border: 2px solid #00ff99;
    color: #f5f5f5;
    font-family: 'Poppins', sans-serif;
    line-height: 1.6;
}

/* T√≠tulo de la secci√≥n */
.monet-expl-card h3 {
    text-align: center;
    font-size: 2.2em;
    font-family: 'Orbitron', sans-serif;
    color: #ff00aa;
    text-shadow: 0 0 15px #ff00aa80, 0 0 20px #00ff9980;
    margin-bottom: 25px;
    padding-bottom: 10px;
    border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
}

/* Subt√≠tulos de pasos */
.monet-expl-card h4 {
    font-size: 1.4em;
    color: #00ff99;
    text-shadow: 0 0 5px #00ff9980;
    margin-top: 25px;
    border-left: 5px solid #ff00aa;
    padding-left: 10px;
}

/* Resaltado general */
.highlight-val {
    color: #00ffcc;
    font-weight: 700;
    text-shadow: 0 0 8px #00ffcc80;
}

/* Resaltado de dinero */
.money-gain {
    color: #00ff99;
    font-weight: 700;
    font-size: 1.1em;
    text-shadow: 0 0 8px #00ff99aa;
}

.money-loss {
    color: #ffb3e6;
    font-weight: 700;
    font-size: 1.1em;
}

/* Contenedor de la conclusi√≥n final */
.final-vnc {
    text-align: center;
    margin-top: 30px;
    padding: 25px;
    border: 2px solid #00ff99;
    border-radius: 15px;
    background: rgba(0, 0, 0, 0.6);
    box-shadow: 0 0 20px #00ff99aa;
}

.final-vnc p {
    font-size: 1.2em;
    margin: 10px 0;
}

.final-vnc .vnc-value {
    font-size: 2.5em;
    font-family: 'Orbitron', sans-serif;
    color: #ff00aa;
    text-shadow: 0 0 20px #ff00aa, 0 0 30px #00ff99;
    display: block;
    margin-top: 15px;
}
</style>

<div class="monet-expl-card">
    <h3>üìà Valoraci√≥n Econ√≥mica del Modelo de Rotaci√≥n</h3>

    <h4>1. El Costo de Fallar (Foco en el FN)</h4>
    <p>Para la monetizaci√≥n, definimos la Matriz de Costos ($C$) enfoc√°ndonos en el error m√°s costoso: el <strong class="highlight-val">Falso Negativo (FN)</strong>, donde el modelo dice que el empleado se queda [0], pero realmente rota [1].</p>
    <ul>
        <li>El costo de rotaci√≥n (FN) fue valorado en <span class="money-loss">$-10,000 USD</span>.</li>
        <li>El beneficio de la retenci√≥n exitosa (VP) es de <span class="money-gain">$+9,000 USD</span>.</li>
        <li>El costo de retener innecesariamente (FP) es de <span class="money-loss">$-1,000 USD</span>.</li>
    </ul>

    <h4>2. Ganancia del Modelo vs. Escenario Base</h4>
    <p>Contrastamos el resultado econ√≥mico de usar la <strong class="highlight-val">Regresi√≥n Log√≠stica</strong> con el Escenario Base de **"no hacer nada"** (asumir que nadie rota).</p>

    <p>üëâ **Ganancia del Escenario Base (No Acci√≥n):** <span class="money-loss">$-590,000.00 USD</span>.</p>
    <p style="padding-left: 20px; font-size: 0.95em;">‚Äî Este valor representa la p√©rdida inevitable de rotaci√≥n si la empresa no interviniera (el costo de los FN que ocurren por no actuar).</p>

    <p>üëâ **Ganancia del Modelo Campe√≥n (Regresi√≥n Log√≠stica):** <span class="money-gain">$61,000.00 USD</span>.</p>
    <p style="padding-left: 20px; font-size: 0.95em;">‚Äî El modelo logra una ganancia neta positiva tras contabilizar todos los costos y beneficios de sus predicciones.</p>

    <hr style="border-top: 1px dashed rgba(255, 255, 255, 0.2); margin: 25px 0;">

    <div class="final-vnc">
        <p>El Valor Neto de la Clasificaci√≥n (VNC) es la diferencia entre ambos, representando el valor econ√≥mico **adicional** generado por el modelo:</p>

        <p class="vnc-value">VNC: $651,000.00 USD</p>

        <p style="font-style: italic; color: #ffb3e6;">
            <strong>Conclusi√≥n:</strong> La implementaci√≥n del modelo es una inversi√≥n altamente rentable, generando <span class="money-gain">m√°s de medio mill√≥n de d√≥lares</span> en valor adicional frente a la inacci√≥n.
        </p>
    </div>
</div>
''')

# @title
from IPython.display import HTML

HTML('''
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;500&display=swap');

/* Contenedor principal del Mapa de Flujo */
.flow-container {
    max-width: 950px;
    margin: 40px auto;
    background: radial-gradient(circle at center, #1a0033 0%, #000000 100%);
    border-radius: 25px;
    padding: 30px 20px;
    box-shadow: 0 0 30px #00ff9980;
    font-family: 'Poppins', sans-serif;
    color: #f5f5f5;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.flow-header {
    font-size: 2.4em;
    font-family: 'Orbitron', sans-serif;
    color: #ff00aa;
    text-shadow: 0 0 15px #ff00aa80, 0 0 20px #00ff9980;
    margin-bottom: 30px;
    text-align: center;
}

/* Estilo para cada paso (Nodo) */
.flow-node {
    width: 90%;
    margin: 15px 0;
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    position: relative;
    transition: transform 0.3s, box-shadow 0.3s;
}

.flow-node:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(255, 255, 255, 0.1);
}

.flow-node h4 {
    font-family: 'Orbitron', sans-serif;
    margin-top: 0;
    font-size: 1.3em;
}

/* Estilo de la flecha/l√≠nea de conexi√≥n */
.flow-arrow {
    width: 2px;
    height: 30px;
    background: linear-gradient(to bottom, #00ff99, #ff00aa);
    box-shadow: 0 0 10px #00ff99;
    margin: 5px 0;
}

/* Estilos Espec√≠ficos para el Contenido */

/* 1. Punto de Partida: Escenario Base */
.node-start {
    background: rgba(255, 0, 170, 0.2);
    border: 2px solid #ff00aa;
    box-shadow: 0 0 15px #ff00aa;
}
.node-start h4 {
    color: #ffb3e6;
}
.node-start .value {
    color: #ffb3e6;
    font-weight: 700;
    font-size: 1.2em;
}

/* 2. El Impacto de la Clasificaci√≥n */
.node-process {
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid #00ff99;
}
.node-process h4 {
    color: #00ff99;
}
.node-process strong {
    color: #ff00aa;
}

/* 3. Ganancia Bruta del Modelo */
.node-result {
    background: rgba(0, 255, 153, 0.2);
    border: 2px solid #00ff99;
    box-shadow: 0 0 15px #00ff99;
}
.node-result h4 {
    color: #00ffcc;
}
.node-result .value {
    color: #00ff99;
    font-weight: 700;
    font-size: 1.2em;
}

/* 4. Conclusi√≥n Final (VNC) */
.node-final {
    background: linear-gradient(135deg, #00ff99, #ff00aa);
    color: #000;
    padding: 30px;
    border: 3px solid #f5f5f5;
    box-shadow: 0 0 30px #ff00aa, 0 0 50px #00ff99;
}
.node-final h4 {
    color: #1a0033;
    font-size: 1.5em;
    text-shadow: none;
}
.node-final .vnc-value {
    font-size: 3em;
    font-family: 'Orbitron', sans-serif;
    color: #1a0033;
    text-shadow: 0 0 5px #f5f5f5;
    display: block;
}
</style>

<div class="flow-container">
    <h1 class="flow-header">Mapa de Flujo de la Monetizaci√≥n</h1>

    <div class="flow-node node-start">
        <h4>Paso 1: Punto de Partida (Inacci√≥n)</h4>
        <p>El Escenario Base representa el costo de la rotaci√≥n que ocurre cuando <strong>no se usa el modelo</strong> (asumir Predicci√≥n 0).</p>
        <p>Ganancia del Escenario Base: <span class="value">$-590,000.00 USD</span></p>
    </div>

    <div class="flow-arrow"></div>

    <div class="flow-node node-process">
        <h4>Paso 2: La Clasificaci√≥n Activa (Modelo RL)</h4>
        <p>El modelo interviene, generando <strong>Verdaderos Positivos</strong> (Beneficio de $9k) y <strong>Falsos Negativos</strong> (Costo de $10k), y <strong>Falsos Positivos</strong> (Costo de $1k).</p>
        <p>El objetivo es maximizar VP y minimizar FN.</p>
    </div>

    <div class="flow-arrow"></div>

    <div class="flow-node node-result">
        <h4>Paso 3: Ganancia Total del Modelo Campe√≥n</h4>
        <p>Es la suma de todos los beneficios y costos generados por las predicciones del modelo.</p>
        <p>Ganancia del Modelo Campe√≥n: <span class="value">$61,000.00 USD</span></p>
    </div>

    <div class="flow-arrow" style="height: 40px;"></div>

    <div class="flow-node node-final">
        <h4>Paso 4: Valor Neto de la Clasificaci√≥n (VNC)</h4>
        <p>El VNC mide la ganancia <strong>adicional</strong> de usar el modelo, comparado con la inacci√≥n. (Ganancia Modelo - Ganancia Base).</p>
        <p class="vnc-value">$651,000.00 USD</p>
        <p style="color: #1a0033; font-weight: 700;">El modelo es una inversi√≥n altamente rentable que genera este valor adicional.</p>
    </div>
</div>
''')

# @title
from IPython.display import HTML

HTML('''
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;500&display=swap');

.thanks-container {
    max-width: 800px;
    margin: 60px auto 40px auto;
    background: rgba(0, 0, 0, 0.8);
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    border: 3px solid #ff00aa; /* Borde principal */
    box-shadow: 0 0 25px #00ff9980, 0 0 45px #ff00aa80;
    color: #f5f5f5;
    font-family: 'Poppins', sans-serif;
}

.thanks-container h3 {
    font-size: 2.5em;
    font-family: 'Orbitron', sans-serif;
    color: #00ff99;
    text-shadow: 0 0 10px #00ff99, 0 0 15px #ff00aa;
    margin-bottom: 15px;
    letter-spacing: 2px;
}

.thanks-container p {
    font-size: 1.1em;
    color: #ffb3e6;
    margin-top: 20px;
}

.thanks-container .signature {
    margin-top: 30px;
    font-size: 1.2em;
    color: #00ffcc;
    font-weight: 700;
}
</style>

<div class="thanks-container">
    <h3>¬°GRACIAS POR SU TIEMPO! üöÄ</h3>
    <p>Esperamos que el an√°lisis de desbalance de clases, el desarrollo de modelos y la monetizaci√≥n del Valor Neto de la Clasificaci√≥n (VNC) hayan demostrado el potencial de este proyecto.</p>
    <p>Valoramos mucho la oportunidad de presentarle nuestro trabajo.</p>
    <div class="signature">
        FIN DEL PROYECTO
    </div>
</div>
''')